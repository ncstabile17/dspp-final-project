---
title: "DSPP Final Project"
author: "Nick Stabile"
date: "11/13/2020"
output: html_document
---
**Data Source:** [DC FY19 Economic Development Return on Investment Data spreadsheet](https://dmped.dc.gov/sites/default/files/dc/sites/dmped/publication/attachments/Return%20on%20Investment%20Data_FY15-19_v3.xlsx)

**Data Author:** Office of the Deputy Mayor for Planning and Economic Development (DMPED)

**Github Repo:** [DSPP Final Project](https://github.com/ncstabile17/dspp-final-project)

This data set pulls together economic development investments from across a variety of agencies and programs in the DC government for FY15-19. The data set was created by DMPED as required by the Economic Development Return on Investment Accountability Amendment Act of 2018. Fore more information see DMPED's [FY19 Economic Development Return on Investment Accountability Report](https://dmped.dc.gov/sites/default/files/dc/sites/dmped/publication/attachments/FY19%20ED%20Return%20on%20Investment%20Accountability%20Report.pdf).


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(haven)
library(readxl)
library(scales)
library(stringi)
library(visdat)
library(caret)
library(tidymodels)
library(ranger) 
library(xgboost)
library(vip)
library(sf)
```

TODO: Add GBM model
TODO: Clean up comments and any extraneous code
TODO: Make sure everything is formatted properly
TODO: Add commentary and analysis and add to Github Pages

### Data Import and Cleaning
```{r warning = FALSE, message = FALSE, results = FALSE}

# Removing unneeded variables and making the variable names easier to work with 
dc_housing_investment <- read_csv("data/dc-housing-investment.csv") %>% 
  select(-`Is recipient in compliance with District resident employment requirements?`, 
         -`Amenity Produced or Enhanced`,
         -`Affordable Housing Compliance?  (Covenanted)`,
         -`CBE Compliant?`,
         -`Additional Incentive Benefits`,
         -`Notes`,
         -`Incentive Type`,
         -`Agency`) %>% 
  rename(
    dmped_year = `FY`,
    incentive_name = `Incentive Name`,
    recipient_name = `Recipient Name`,
    incentive_amount = `Incentive Amount`, 
    investment_address = `MAR Address of Investment`,
    ward = `MAR_Ward`,
    ami_30 = `30% AMI`,
    ami_50 = `50% AMI`,
    ami_60 = `60% AMI`,
    ami_80 = `80% AMI`,
    one_br = `1 BRs`,
    two_br = `2 BRs`,
    three_br = `3 BRs`,
    four_plus_br = `4+ BRs`,
    total_dmped_affordable = `Total Affordable Units Produced or Preserved`,
    dc_residents_employed = `Number of District Residents Employed`,
    num_cbes = `Number of CBEs`
    ) %>% 
  # Ensuring variables are consistent and converting to numeric
  # Note that the "HFA Revenue Bond Issuance" was renamed to "HFA Revenue Bond" in 2019 so this code makes all years consistent
  mutate(
    investment_address = str_to_upper(investment_address),
    ami_30 = as.numeric(ami_30),
    ami_50 = as.numeric(ami_50),
    ami_60 = as.numeric(ami_60),
    ami_80 = as.numeric(ami_80),
    one_br = as.numeric(one_br),
    two_br = as.numeric(two_br),
    three_br = as.numeric(three_br),
    four_plus_br = as.numeric(four_plus_br),
    total_dmped_affordable = as.numeric(total_dmped_affordable),
    total_bedrooms = one_br + 2*two_br + 3*three_br + 4*four_plus_br,
    # For both dc_residents_employed and num_cbes some observations have N/A values, while others have Not Available
    # I infer that N/A means "Not Applicable" which would reasonably translate to 0 for my purposes, whereas I replace Not Available values with NA
    num_cbes = as.numeric(str_replace_all(num_cbes, c("Not Available" = "NA", "N/A" = 0))),
    dc_residents_employed = as.numeric(str_replace_all(dc_residents_employed, c("Not Available" = "NA", "N/A" = 0))),
    incentive_name = str_replace_all(incentive_name, c("HFA Revenue Bond Issuance" = "HFARB", "HFA Revenue Bond" = "HFARB", "4% Low Income Housing Tax Credit" = "LIHTC", "9% Low Income Housing Tax Credit" = "LIHTC", "Community Development Block Grant \\(CDBG\\)" = "CDBG", "Creative and Open Space Modernization Grant" = "COSMG", "District of Columbia Business Capital Program" = "CBCP", "DMPED Grant" = "DMPED", "Economic Development Special Account" = "EDSA", "HOME Investment Partnerships Program" = "HOME", "Housing Preservation Fund" = "HPF", "Housing Production Trust Fund" = "HPTF", "Industrial Revenue Bond" = "IRB", "Land Disposition Agreement" = "LDA", "Legacy Business" = "LBZ", "Makerspace Marketplace Grant" = "MMG", "Neighborhood Prosperity Fund" = "NPF", "New Communities Initiative" = "NCI", "Qualified Supermarket Tax Incentive" = "TAX", "Real Property Tax Abatement" = "TAX", "Tax Exemption" = "TAX", "Tax Increment Financing" = "TAX")),
    dmped_lihtc_amount = if_else(incentive_name == "LIHTC", incentive_amount, 0),
    ward = na_if(ward, "N/A")
  ) %>% 
  # Standardizing quadrant parts of address 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "NORTHEAST", 
    replacement = "NE"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "SOUTHEAST", 
    replacement = "SE"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "NORTHWEST", 
    replacement = "NW"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "SOUTHWEST", 
    replacement = "SW"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "STREET", 
    replacement = "ST"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "ROAD", 
    replacement = "RD"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "PLACE", 
    replacement = "PL"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "AVENUE", 
    replacement = "AVE"
    )

# Removing commas and periods from addresses for consistency
dc_housing_investment$investment_address <- str_remove_all(dc_housing_investment$investment_address, "[,.]")

```

```{r}

# Doing similar importing and cleaning for additional project data that has market rate unit data
affordable_proj_market_rate <- read_csv("data/affordable-projects-market-rate.csv") %>% 
  select(-`Projected or Actual Construction Completion Date`,
         -`External Project Website`,
         -`Project Type/Scope`) %>% 
  rename(
    investment_address = `Address`,
    total_units = `Total Units`,
    loan_grant_amount = `Loan/Grant Amount`,
    dhcd_lihtc_amount = `LIHTC Allocation`,
    ami_0_30 = `0-30% AMI units`,
    ami_31_50 = `31-50% AMI Units`,
    ami_51_80 = `51-80% AMI Units`,
    ami_81 = `81%+ AMI / Market Rate`,
    dhcd_year = `Projected or Actual Closing Date`,
    total_dhcd_affordable = `Affordable Units`,
    psh_units = `PSH Units`,
    funding_sources = `Funding Sources`
  ) %>%
  mutate(
    investment_address = str_to_upper(investment_address),
    market_rate_units = total_units - total_dhcd_affordable,
    total_units = as.numeric(total_units),
    loan_grant_amount = replace_na(as.numeric(gsub('[\\$,]', '', loan_grant_amount)), 0),
    dhcd_lihtc_amount = replace_na(as.numeric(gsub('[\\$,]', '', dhcd_lihtc_amount)), 0),
    dhcd_year = as.Date(dhcd_year, "%m/%d/%y"),
    total_investment = dhcd_lihtc_amount + loan_grant_amount
  ) %>% 
  separate(funding_sources, c("funding_source1", "funding_source2")) %>% 
  filter(!is.na(total_units)) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "NORTHEAST", 
    replacement = "NE"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "SOUTHEAST", 
    replacement = "SE"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "NORTHWEST", 
    replacement = "NW"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "SOUTHWEST", 
    replacement = "SW"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "STREET", 
    replacement = "ST"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "ROAD", 
    replacement = "RD"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "PLACE", 
    replacement = "PL"
    ) %>% 
  mutate_if(
    is.character, 
    str_replace_all, 
    pattern = "AVENUE", 
    replacement = "AVE"
    )

affordable_proj_market_rate$investment_address <- str_remove_all(affordable_proj_market_rate$investment_address, "[,.]")

```

```{r}

# Getting total investment data by project for both data sets

investment_by_project <- affordable_proj_market_rate %>% 
  group_by(investment_address) %>% 
  summarize(total_dhcd_investment = sum(total_investment))

affordable_proj_market_rate <- 
  left_join(affordable_proj_market_rate, investment_by_project, by = "investment_address")

total_proj_data <- dc_housing_investment %>% 
  group_by(investment_address) %>% 
  summarize(total_dmped_investment = sum(incentive_amount))

dc_housing_investment <- 
  left_join(dc_housing_investment, total_proj_data, by = "investment_address")
```

```{r}

# Merging the existing data set with market rate data set and recoding some variables
# Since I will be doing project-level analysis rather than investment-level, I remove duplicate entries by address

# The investment and unit data from the two data sets do not always line up
# I compare the investment amount and take the larger of the values assuming that the data set with a larger investment value is more up to date with recent funding allocation
# I do the same with the affordable unit data 
# Before comparing, I replace missing values with 0 for the corresponding variables from the other data set that are created when joining
# This process also affects projects in the DMPED data set that had NA values for total affordable housing; this makes sense because these NA values existed for investments that would not have been expected to produce any affordable housing (i.e. a business grant or tax exemption for a museum)
# I also align the AMI variables so all projects with data for these variables are using the same variable, with the DHCD data set as the default
# I then use the address variable to create a separate quadrant variable

combined_data <- 
  full_join(dc_housing_investment, affordable_proj_market_rate, by = "investment_address") %>% 
  distinct(investment_address, .keep_all= TRUE) %>% 
  mutate(total_dmped_investment = replace_na(total_dmped_investment, 0),
         total_dhcd_investment = replace_na(total_dhcd_investment, 0),
         total_dmped_affordable = replace_na(total_dmped_affordable, 0),
         total_dhcd_affordable = replace_na(total_dhcd_affordable, 0),
         dhcd_lihtc_amount = replace_na(dhcd_lihtc_amount, 0),
         dmped_lihtc_amount = replace_na(dmped_lihtc_amount, 0),
         total_proj_investment = if_else(total_dmped_investment > total_dhcd_investment, total_dmped_investment, total_dhcd_investment),
         total_proj_affordable = if_else(total_dmped_affordable > total_dhcd_affordable, total_dmped_affordable, total_dhcd_affordable),
         ami_0_30 = if_else((is.na(ami_0_30) & !is.na(ami_30)), ami_30, ami_0_30),
         ami_31_50 = if_else((is.na(ami_31_50) & !is.na(ami_50)), ami_50, ami_31_50),
         ami_51_80 = if_else((is.na(ami_51_80) & !is.na(ami_80) & !is.na(ami_60)), ami_60 + ami_80, ami_51_80),
         proj_funding_source = as.factor(if_else(is.na(incentive_name), funding_source1, incentive_name)),
         proj_lihtc_amount = if_else(dhcd_lihtc_amount > dmped_lihtc_amount, dhcd_lihtc_amount, dmped_lihtc_amount),
         investment_year = as.factor(if_else(is.na(dhcd_year) & !is.na(dmped_year), as.character(str_sub(dmped_year, -2, -1)), as.character(format(dhcd_year, '%y')))),
         quadrant = str_sub(investment_address, -2, -1),
         quadrant = if_else(quadrant %in% c("NE", "NW", "SW", "SE"), quadrant, "NA")
         )


```

```{r}

# I want to plot the investment and total unit production
# For this, I exclude projects that did not produce any housing (N = 147), projects without investment data (N = 85), and those that produced affordable units, but did not have clear data on total units for the project (N = 30)

total_unit_investment_data <- combined_data %>% 
  filter(!is.na(total_units) & total_proj_investment > 0) %>% 
  mutate(investment_per_unit = total_proj_investment/total_units,
         investment_year = as.numeric(str_sub(`Projected or Actual Closing Date`, -2, -1)))

total_unit_investment_data %>% 
  ggplot(aes(x = total_proj_investment, 
        y = total_units)) +
  geom_point(
    aes(color = if_else(market_rate_units > 0, "Yes", "No"))) +
  geom_smooth(method=lm) +
  labs(title = "Total Investment by Affordable Units",
       color = "Project with Market Rate Units") +
  scale_x_continuous(labels = comma) +
  scale_color_manual(values = c("black", "red")) +
  theme_minimal()

total_unit_investment_data %>% 
  mutate(has_market_rate = if_else(market_rate_units > 0, TRUE, FALSE)) %>% 
  ggplot() +
  geom_histogram(
    aes(x = investment_per_unit),
    color="black", 
    fill="white",
    binwidth = 10000) +
  scale_x_continuous(labels = comma) +
  facet_wrap(~ has_market_rate)

total_unit_investment_data %>% 
  mutate(investment_year = if_else((is.na(investment_year) & !is.na(year)), as.numeric(str_sub(year, -2, -1)), investment_year)) %>% 
  ggplot() +
  geom_histogram(
    aes(x = investment_per_unit),
    color="black", 
    fill="white",
    binwidth = 10000) +
  scale_x_continuous(labels = comma) +
  facet_wrap(~ investment_year)

# Want to look at the investment per unit and relationship to number of affordable units produced
total_unit_investment_data %>% 
  ggplot(aes(x = investment_per_unit, 
        y = total_proj_affordable)) +
  geom_point() +
  geom_smooth(method=lm) +
  labs(title = "Total Investment by Affordable Units") +
  scale_x_continuous(labels = comma) +
  theme_minimal()

total_unit_investment_data %>% 
  ggplot(aes(x = investment_per_unit, 
        y = ami_0_30)) +
  geom_point() +
  geom_smooth(method=lm) +
  labs(title = "Total Investment by Affordable Units") +
  scale_x_continuous(labels = comma) +
  theme_minimal()

total_unit_investment_data %>% 
  ggplot(aes(x = investment_per_unit, 
        y = ami_81)) +
  geom_point() +
  geom_smooth(method=lm) +
  labs(title = "Total Investment by Affordable Units") +
  scale_x_continuous(labels = comma) +
  theme_minimal()
  

```

```{r}

# I can just use the Open Data Affordable Housing data set for mapping if I want to
# It already has location information, but they don't match up well with the addresses from the other data sets

dc_aff_housing_open <- 
  read_csv("data/dc-aff-housing-open.csv", 
                            col_type = cols(
                              LATITUDE = col_character(),
                              LONGITUDE = col_character()
                            )) %>% 
  rename_with(tolower) %>% 
  filter(!is.na(address_id) & !is.na(longitude) & !is.na(latitude))

dc_aff_housing_open <- st_as_sf(
  dc_aff_housing_open,
  coords = c("longitude", "latitude"),
  crs = 4326,
  remove = FALSE)

dc_tracts <- st_read("data/Census_Tracts_in_2010.shp") %>% 
  select(TRACT, GEOID, geometry)

# Affordabl housing doesn't have tract or geoID information, adding additional data source
dc_addresses <- st_read("data/Address_Points.csv") %>% 
  select(address_id = ADDRESS_ID, TRACT = CENSUS_TRACT) %>% 
  mutate(address_id = as.numeric(address_id))

dc_aff_housing_open <- 
  left_join(dc_aff_housing_open, dc_addresses, by = "address_id")

dc_aff_housing_merged <- st_join(
  dc_aff_housing_open, # points
  dc_tracts, # polygons
  join = st_within
)

dc_aff_housing_merged <- st_set_geometry(dc_aff_housing_merged, NULL)

dc_aff_housing_merged_agg <- dc_aff_housing_merged %>%
  group_by(GEOID) %>%
  summarize(
    total_affordable_units = sum(total_affordable_units),
    total_0_30_ami = sum(affordable_units_at_0_30_ami)
  )

dc_aff_housing_merged_agg <- dc_tracts %>%
  left_join(dc_aff_housing_merged_agg, by = "GEOID")

dc_aff_housing_merged_agg %>% 
  mutate(total_affordable_units = replace_na(total_affordable_units, 0)) %>% 
  ggplot() +
  geom_sf(aes(fill = total_affordable_units)) + 
  scale_fill_continuous(
    low = "white", high = "blue", name = "Total Affordable Housing Units since 2015"
  ) +
  theme_void()

dc_aff_housing_merged_agg %>% 
  mutate(total_0_30_ami = replace_na(total_0_30_ami, 0)) %>% 
  ggplot() +
  geom_sf(aes(fill = total_0_30_ami)) + 
  scale_fill_continuous(
    low = "white", high = "blue", name = "Total Deeply Affordable Housing Units since 2015"
  ) +
  theme_void()

```
- Funding Sources
- Ward
- Quadrant
- Total Affordable Units
- 30% AMI Units
- 50% AMI Units
- 60% AMI Units
- 80% AMI Units
- Market Rate Units
- Total Bedrooms
- DC residents employed
- Number of certified small businesses served

```{r}

# Predicting amount of investment in a project and total affordable units
# I previously imputed 0 for projects that had NA values for total affordable housing produced as these only existed in the DMPED data set and are assumed to have not produced any housing (at any affordability levels) based on the description of the investments; I therefore repeat this for the other housing unit affordability level variables and the total_bedrooms variable

prediction_data <- combined_data %>% 
  select(total_proj_investment, proj_lihtc_amount, total_proj_affordable, quadrant, ami_0_30, ami_31_50, ami_51_80, ami_81, ward, dc_residents_employed, num_cbes, total_bedrooms, investment_year, proj_funding_source) %>% 
  mutate(ami_0_30 = if_else(total_proj_affordable == 0, 0, ami_0_30),
         ami_31_50 = if_else(total_proj_affordable == 0, 0, ami_31_50),
         ami_51_80 = if_else(total_proj_affordable == 0, 0, ami_51_80),
         ami_81 = if_else(total_proj_affordable == 0, 0, ami_81)
         )


set.seed(20201212)
# create a split object
aff_investment_split <- initial_split(data = prediction_data, prop = 0.75)
# create the training and testing data
aff_investment_train <- training(x = aff_investment_split)
aff_investment_test <- testing(x = aff_investment_split)

# create resamples
aff_investment_folds <- vfold_cv(data = aff_investment_train, v = 5)


```

```{r}

# Predicting investment in a project

# Outcome variable is right-skewed so will normalize
aff_investment_train %>% 
  ggplot() +
  geom_histogram(
    aes(x = total_proj_investment),
    bins = 50,
    fill = "blue") +
  scale_x_continuous(labels = comma) + 
  theme_minimal()

# Significant number of missing values across particular variables occur because I combine two data sets, and some projects were only present in one of the data sets which did not have data for particular variables including dc_residents_employed, num_cbes, total_bedrooms, total_funding_sources, and investment_year
# I choose not to impute these with mean/median or with an algorithm because I'm not confident the other predictors would be very accurate at predicting the missing values for these variables and tree-based algorithms (which I'm planning to utilize) are able to handle missing values
vis_miss(aff_investment_train, cluster = TRUE)

# I have no zero-variance predictors, but a few near-zero predictors so these will be filtered out as part of the recipe
nearZeroVar(aff_investment_train, saveMetrics = TRUE) %>% 
  rownames_to_column() %>% 
  filter(nzv)

# I'm also going to follow Boehmke and Greenwell's advice to "when in doubt, normalize"
predict_investment_recipe <- 
  recipe(total_proj_investment ~ ., data = aff_investment_train) %>%
  step_nzv(all_predictors()) %>% 
  step_bagimpute(all_predictors()) %>% 
  step_BoxCox(all_numeric()) %>% 
  step_other(investment_year, threshold = 0.10, 
             other = "other") %>% 
  step_other(proj_funding_source, threshold = 0.05, 
             other = "OTHER")


```


```{r}

# KNN Model to predict investment

# create model object
predict_investment_knn_mod <-
  nearest_neighbor(neighbors = tune()) %>%
  set_engine(engine = "kknn") %>%
  set_mode(mode = "regression")

# create workflow
predict_investment_knn_workflow <-
  workflow() %>%
  add_model(spec = predict_investment_knn_mod) %>%
  add_recipe(recipe = predict_investment_recipe)

# create tuning grid for knn hyperparameters
predict_investment_knn_grid <- tibble(neighbors = c(7, 9, 11, 13))

# estimate models
predict_investment_knn_res <-
  predict_investment_knn_workflow %>%
  tune_grid(resamples = aff_investment_folds,
            grid = predict_investment_knn_grid,
            control = control_grid(save_pred = TRUE),
            metrics = metric_set(rmse))

show_best(predict_investment_knn_res, "rmse", n = 10)


```

```{r}
# Random Forest model to predict investment

# create model object
predict_investment_rf_mod <- 
    rand_forest(mtry = tune(), trees = tune(), min_n = tune()) %>%
    set_mode("regression") %>%
    set_engine("ranger", importance = "impurity")

# create workflow
predict_investment_rf_workflow <-
  workflow() %>%
  add_model(spec = predict_investment_rf_mod) %>%
  add_recipe(recipe = predict_investment_recipe)

n_features <- length(setdiff(names(predict_investment_train), "total_proj_investment"))

# create tuning grid for rf hyperparamters
predict_investment_rf_grid <- expand.grid(
  mtry = floor(n_features * c(.25, .333, .4)),
  min_n = c(1, 5, 10), 
  trees = c(n_features*10)
)

# estimate models
predict_investment_rf_res <- 
  predict_investment_rf_workflow %>%
  tune_grid(resamples = aff_investment_folds,
            grid = predict_investment_rf_grid,
            control = control_grid(save_pred = TRUE),
            metrics = metric_set(rmse))

show_best(predict_investment_rf_res, "rmse", n = 10)

# Re-running model with best specification to get variable importance
predict_investment_rf_mod_vip <- 
    rand_forest(mtry = 3, trees = 130, min_n = 10) %>%
    set_mode("regression") %>%
    set_engine("ranger", importance = "impurity")

# Fitting model to training data
predict_investment_rf_fit_vip <-
  workflow() %>%
  add_model(spec = predict_investment_rf_mod_vip) %>%
  add_recipe(recipe = predict_investment_recipe) %>% 
  fit(aff_investment_train)

# Plotting variable importance
predict_investment_rf_fit_vip %>%
  pull_workflow_fit() %>%
  vip(num_features = 10)

```

```{r}

# Boosted Tree model to predict investment in a project

# create model object
predict_investment_xgboost_mod <- 
  boost_tree(
    trees = tune(),
    min_n = tune(),
    tree_depth = tune(),
    learn_rate = tune(),
    loss_reduction = tune()) %>%
  set_engine("xgboost") %>% 
  set_mode("regression")

# create workflow
predict_investment_xgboost_workflow <-
  workflow() %>%
  add_model(spec = predict_investment_xgboost_mod) %>%
  add_recipe(recipe = predict_investment_recipe)

predict_investment_xgboost_grid <- expand.grid(
  trees = c(100, 500, 1000),
  min_n = 1,
  tree_depth = 6,
  learn_rate = .3,
  loss_reduction = 0
)

# estimate models
predict_investment_xgboost_res <- 
  predict_investment_xgboost_workflow %>%
  tune_grid(resamples = aff_investment_folds,
            grid = predict_investment_xgboost_grid,
            control = control_grid(save_pred = TRUE),
            metrics = metric_set(rmse))

show_best(predict_investment_rf_res, "rmse", n = 10)

# grid specification
xgboost_params <- 
  dials::parameters(
    min_n(),
    tree_depth(),
    learn_rate(),
    loss_reduction()
  )

xgboost_grid <- 
  dials::grid_max_entropy(
    xgboost_params, 
    size = 60
  )




```


```{r}

# Predicting the affordable units in a project

# Outcome variable is right skewed
aff_investment_train %>% 
  ggplot() +
  geom_histogram(
    aes(x = total_proj_affordable),
    bins = 50,
    fill = "blue") +
  scale_x_continuous(labels = comma) + 
  theme_minimal()

predict_aff_units_recipe <- 
  recipe(total_proj_affordable ~ ., data = predict_investment_train) %>%
  step_nzv(all_predictors()) %>% 
  step_bagimpute(all_predictors()) %>% 
  step_BoxCox(all_numeric()) %>% 
  step_other(investment_year, threshold = 0.10, 
             other = "other") %>% 
  step_other(proj_funding_source, threshold = 0.05, 
             other = "OTHER")


```

```{r}

# Random forest model to predict affordable housing units

# create model object
predict_aff_rf_mod <- 
    rand_forest(mtry = tune(), trees = tune(), min_n = tune()) %>%
    set_mode("regression") %>%
    set_engine("ranger")

# create workflow
predict_aff_rf_workflow <-
  workflow() %>%
  add_model(spec = predict_aff_rf_mod) %>%
  add_recipe(recipe = predict_aff_units_recipe)

n_features <- length(setdiff(names(aff_investment_train), "total_proj_affordable"))

# create tuning grid for rf hyperparamters
predict_aff_rf_grid <- expand.grid(
  mtry = floor(n_features * c(.25, .333, .4)),
  min_n = c(1, 5, 10), 
  trees = c(n_features*10)
)

# estimate models
predict_aff_rf_res <- 
  predict_aff_rf_workflow %>%
  tune_grid(resamples = aff_investment_folds,
            grid = predict_aff_rf_grid,
            control = control_grid(save_pred = TRUE),
            metrics = metric_set(rmse))

show_best(predict_aff_rf_res, "rmse", n = 10)

# Re-running model with best specification to get variable importance
predict_aff_rf_mod_vip <- 
    rand_forest(mtry = 5, trees = 130, min_n = 1) %>%
    set_mode("regression") %>%
    set_engine("ranger", importance = "impurity")

# Fitting model to training data
predict_aff_rf_fit_vip <-
  workflow() %>%
  add_model(spec = predict_aff_rf_mod_vip) %>%
  add_recipe(recipe = predict_aff_units_recipe) %>% 
  fit(aff_investment_train)

# Plotting variable importance
predict_aff_rf_fit_vip %>%
  pull_workflow_fit() %>%
  vip(num_features = 10)

```

```{r}

# KNN Model to predict affordable units in project

# create model object
predict_aff_knn_mod <-
  nearest_neighbor(neighbors = tune()) %>%
  set_engine(engine = "kknn") %>%
  set_mode(mode = "regression")

# create workflow
predict_aff_knn_workflow <-
  workflow() %>%
  add_model(spec = predict_aff_knn_mod) %>%
  add_recipe(recipe = predict_aff_units_recipe)

# create tuning grid for knn hyperparameters
predict_aff_knn_grid <- tibble(neighbors = c(7, 9, 11, 13))

# estimate models
predict_aff_knn_res <-
  predict_aff_knn_workflow %>%
  tune_grid(resamples = aff_investment_folds,
            grid = predict_aff_knn_grid,
            control = control_grid(save_pred = TRUE),
            metrics = metric_set(rmse))

show_best(predict_aff_knn_res, "rmse", n = 10)


```


```{r}


         unit_cost = if_else(total_units > 0, total_proj_investment/total_units, 0),
         affordable_cost = if_else(total_proj_affordable > 0, total_proj_investment/total_proj_affordable, 0),
         ami_30_cost = if_else(ami_0_30 > 0, total_proj_investment/ami_30_ratio, 0)


```


